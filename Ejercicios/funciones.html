<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funciones en JS</title>
    <link rel="stylesheet" href="../CSS/estilo.css">
</head>
<body>
    <a href="../index.html" class="btn-regresar">⬅ Regresar al inicio</a>
    <h1>Funciones de JavaScript</h1>

    <!-- Ejemplo 1 -->

   <section class="ejercicio">
   <h2>Suma de dos numeros</h2> 
   <p class="descripcion">
     Este ejercicio se centra en la creación de funciones para sumar dos números, utilizando tanto la sintaxis de función tradicional como la de función flecha, para ello puedes utilizar la consola o un documento.
   </p>
   <div class="contenido">
     <div class="codigo-img">
       <img src="../Imagenes/funciones1.PNG" alt="Código del ejercicio">
     </div>

     <!-- Ejecución -->
    <div class="codigo-ejecucion">
    <h2>Usando Función Tradicional</h2>
    <button id="accion">iniciar suma</button>
    <p id="resultado"></p>

    <script>
        function sumar(a, b) {
        return a + b;
        }
        // Evento para el botón
        document.getElementById('accion').addEventListener('click', () => {
        let num1 = parseFloat(prompt("Ingresa el primer número:"));
        let num2 = parseFloat(prompt("Ingresa el segundo número:"));
        let suma = sumar(num1, num2);
        document.getElementById('resultado').textContent = "Resultado = " + suma;
        });
    </script>
    </div>
     <div class="codigo-ejecucion">
       <h2>Usando Funcion Flecha</h2>
        <button id="accion2">iniciar suma</button>
        <p id="resultado2"></p>
       <script>
        const sumarflecha = (a,b) => a+b;
        // Evento para el botón
        document.getElementById('accion2').addEventListener('click', () => {
        let num1 = parseFloat(prompt("Ingresa el primer número:"));
        let num2 = parseFloat(prompt("Ingresa el segundo número:"));
        let suma = sumarflecha(num1, num2);
        document.getElementById('resultado2').textContent = "Resultado = " + suma;
        });
       </script>
     </div>
   </div>
</section>

<!-- Ejemplo 2 -->

<section class="ejercicio">
   <h2>Division de dos numeros</h2>
   <!-- Descripción -->
   <p class="descripcion">
     Manejando el caso de división por cero.
   </p>
   <!-- Contenido -->
   <div class="contenido">
     <!-- Imagen del código -->
     <div class="codigo-img">
       <img src="../Imagenes/funciones2.PNG" alt="Código del ejercicio">
     </div>

     <!-- Ejecución -->
     <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion Tradicional</h2>
       <button id="accion3">Realizar Division</button>
       <p id="resultado3"></p>
       <script>
        function dividir(a,b) {
          if (b === 0) {
            return 'error dividir entre 0'
          }
          return a/b;
        }

        document.getElementById('accion3').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = dividir(num1, num2);
          document.getElementById('resultado3').textContent = "Resultado = " + resultado;
        });
       </script>
     </div>
     <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion flecha</h2>
       <button id="accion4">Realizar Division</button>
       <p id="resultado4"></p>
       <script>
        const dividirFlecha = (a,b) => {
          if (b === 0) {
            return 'error dividir entre 0'
          }
          return a/b;
        }

        document.getElementById('accion4').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = dividirFlecha(num1, num2);
          document.getElementById('resultado4').textContent = "Resultado = " + resultado;
        });
       </script>
     </div>
   </div>
</section>

<!-- Ejemplo 3 -->
<section class="ejercicio">
  <!-- Descripción -->
  <h2>Potencia de dos numeros</h2>
  <p class="descripcion">Este ejercicio se centra en la creación de funciones para calcular la potencia de un número, utilizando tanto la sintaxis de función tradicional como la de función flecha, para ello puedes utilizar la consola o un documento.</p>
  <!-- Contenido -->

  <div class="contenido">
    <!-- Imagen del código -->
    <div class="codigo-img">
      <img src="../Imagenes/funciones3.PNG" alt="Código del ejercicio">
    </div>
  <!-- Ejecución -->
    <div class="codigo-ejecucion">
      <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion Tradicional</h2>
       <button id="accion5">Realizar potencia</button>
        <p id="resultado5"></p>
       <script>
        function potencia(base, exponente) {
          return Math.pow(base, exponente);
        }
        document.getElementById('accion5').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = potencia(num1, num2);
          document.getElementById('resultado5').textContent = "Resultado = " + resultado;
        });
       </script>
    </div>
    <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion flecha</h2>
       <button id="accion6">Realizar potencia</button>
       <p id="resultado6"></p>
       <script>
        const potenciaFlecha = (base, exponente) => 
          Math.pow(base, exponente);

        document.getElementById('accion6').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = potenciaFlecha(num1, num2);
          document.getElementById('resultado6').textContent = "Resultado = " + resultado;
        });
       </script>
    </div>
  </div>
</section>
<section class="ejercicio">
  <!-- Descripción -->
  <h2>Mayor de 2 números</h2>
  <p class="descripcion">Este ejercicio se centra en la creación de funciones para encontrar el mayor de dos números, utilizando tanto la sintaxis de función tradicional como la de función flecha, para ello puedes utilizar la consola o un documento.</p>
  <!-- Contenido -->

  <div class="contenido">
    <!-- Imagen del código -->
    <div class="codigo-img">
      <img src="../Imagenes/funciones4.PNG" alt="Código del ejercicio">
    </div>
  <!-- Ejecución -->
    <div class="codigo-ejecucion">
      <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion Tradicional</h2>
       <button id="accion7">Comparar numeros</button>
       <p id="resultado7"></p>
       <script>
        function mayor(num1, num2) {
          if (num1 > num2) {
            return num1;
          } else {
            return num2;
          }
        }
        document.getElementById('accion7').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = mayor(num1, num2);
          document.getElementById('resultado7').textContent = "Mayor = " + resultado;
        });
       </script>

    </div>
    <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion flecha</h2>
       <button id="accion8">Comparar numeros</button>
       <p id="resultado8"></p>
       <script>
        const mayorFlecha = (num1, num2) => (num1 > num2 ? num1 : num2);

        document.getElementById('accion8').addEventListener('click', () => {
          let num1 = parseFloat(prompt("Ingresa el primer número:"));
          let num2 = parseFloat(prompt("Ingresa el segundo número:"));
          let resultado = mayorFlecha(num1, num2);
          document.getElementById('resultado8').textContent = "Mayor = " + resultado;
        });
       </script>
    </div>
  </div>
</section>

<!-- Ejercicio 1 -->

<section class="ejercicio">
  <!-- Descripción -->
  <h2>Ejercicio 1</h2>
  <p class="descripcion">En este ejercicio se centra en la creación de funciones para calcular el factorial de un número, utilizando tanto la sintaxis de función tradicional como la de función flecha, para ello puedes utilizar la consola o un documento.</p>
  <!-- Contenido -->

  <div class="contenido">
    <!-- Imagen del código -->
    <div class="codigo-img">
      <img src="../Imagenes/funciones_ejemplo1.PNG" alt="Código del ejercicio">
    </div>
  <!-- Ejecución -->
    <div class="codigo-ejecucion">
      <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion Tradicional</h2>
       <button id="accion9">Calcular factorial</button>
       <p id="resultado9"></p>
       <script>
        // Funcion tradicional recursiva
          function factorial(n) {
              if (n === 0 || n === 1) {
                  return 1;
              }
              return n * factorial(n - 1);
          }
          document.getElementById('accion9').addEventListener('click', () => {
              let num = parseInt(prompt("Ingresa un número para calcular su factorial:"));
              if (isNaN(num) || num < 0) {
                  document.getElementById('resultado9').textContent = "Por favor, ingresa un número entero no negativo.";
              } else {
                  let resultado = factorial(num);
                  document.getElementById('resultado9').textContent = "Factorial de " + num + " es " + resultado;
              }
          });
       </script>

    </div>
    <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion flecha</h2>
       <button id="accion10">Calcular factorial</button>
       <p id="resultado10"></p>
       <script>
        // Funcion flecha recursiva
        const factorialFlecha = (n) => {
            if (n === 0 || n === 1) {
                return 1;
            }
            return n * factorialFlecha(n - 1);
        };
        document.getElementById('accion10').addEventListener('click', () => {
            let num = parseInt(prompt("Ingresa un número para calcular su factorial:"));
            if (isNaN(num) || num < 0) {
                document.getElementById('resultado10').textContent = "Por favor, ingresa un número entero no negativo.";
            } else {
                let resultado = factorialFlecha(num);
                document.getElementById('resultado10').textContent = "Factorial de " + num + " es " + resultado;
            }
        });
       </script>
    </div>
  </div>
</section>

<!-- Ejercicio 2 -->

<section class="ejercicio">
  <!-- Descripción -->
  <h2>Ejercicio 2</h2>
  <p class="descripcion">Este ejercicio se centra en ingresar la posicion de un numero en la serie fibonacci y esta te devuelva el valor del numero</p>
  <!-- Contenido -->

  <div class="contenido">
    <!-- Imagen del código -->
    <div class="codigo-img">
      <img src="../Imagenes/fibonacci.PNG" alt="Código del ejercicio">
    </div>
  <!-- Ejecución -->
    <div class="codigo-ejecucion">
      <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion Tradicional</h2>
       <button id="accion11">Comparar numeros</button>
       <p id="resultado11"></p>
       <script>
        function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
        document.getElementById('accion11').addEventListener('click', () => {
          let num = parseInt(prompt("Ingresa un número para calcular su Fibonacci:"));
          if (isNaN(num) || num < 0) {
              document.getElementById('resultado11').textContent = "Por favor, ingresa un número entero no negativo.";
          } else {
              let resultado = fibonacci(num);
              document.getElementById('resultado11').textContent = "Fibonacci de " + num + " es " + resultado;
          }
        });
       </script>

    </div>
    <div class="codigo-ejecucion">
       <!-- Aquí pegas tu código en vivo -->
       <h2>Funcion flecha</h2>
       <button id="accion12">Comparar numeros</button>
       <p id="resultado12"></p>
       <script>
        const fibonacciflecha = (n) => {
            if (n <= 1) {
                return n;
            }
            return fibonacciflecha(n - 1) + fibonacciflecha(n - 2);
        };
        document.getElementById('accion12').addEventListener('click', () => {
          let num = parseInt(prompt("Ingresa un número para calcular su Fibonacci:"));
          if (isNaN(num) || num < 0) {
              document.getElementById('resultado12').textContent = "Por favor, ingresa un número entero no negativo.";
          } else {
              let resultado = fibonacciflecha(num);
              document.getElementById('resultado12').textContent = "Fibonacci de " + num + " es " + resultado;
          }
        });
       </script>
    </div>
  </div>
</section>

<section class="ejercicio">
    <h2>Función que aplica una operación a un Array</h2>
    <p class="descripcion">
        Este ejercicio muestra cómo crear una función que aplica una operación a cada elemento de un array utilizando el método <strong>map</strong>. Se define una función genérica y luego se le pasa una operación específica (como duplicar) para ser ejecutada.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones6.PNG" alt="Código del ejercicio">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-map-funcion"></div>

            <script>
                // 1. Definición de la función genérica
                function aplicarOperacionAArray(arr, operacion) {
                    return arr.map(operacion);
                }

                // 2. Función de ejemplo que se pasará como argumento
                const duplicar = (x) => x * 2;

                // 3. Pruebas
                const numeros = [1, 2, 3, 4];
                const resultado = aplicarOperacionAArray(numeros, duplicar);

                // Mostramos el resultado en el div
                const contenedor = document.getElementById('resultado-map-funcion');
                
                // Usamos JSON.stringify para mostrar el array de forma legible
                contenedor.innerHTML = `<p>El resultado es: <strong>[${resultado.join(', ')}]</strong></p>`;
                // Salida: El resultado es: [2, 4, 6, 8]
            </script>
        </div>
    </div>
</section>

<section class="ejercicio">
    <h2>Función que aplica una operación a un Array</h2>
    <p class="descripcion">
        Se agreagó una segunda operación, "elevar al cuadrado", para demostrar cómo la función genérica <code>aplicarOperacionAArray</code> puede reutilizarse con diferentes lógicas.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones7.PNG" alt="Código del ejercicio">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-map-funcion2"></div>

            <script>
                // 1. Definición de la función genérica (sin cambios)
                function aplicarOperacionAArray2(arr, operacion2) {
                    return arr.map(operacion2);
                }

                // 2. Primera operación: duplicar
                const duplicar2 = (x) => x * 2;

                // 3. Nueva operación: elevar al cuadrado
                const aCuadrado = (x) => x * x;

                // 4. Pruebas
                const numeros2 = [1, 2, 3, 4];
                const resultadoDuplicado2 = aplicarOperacionAArray2(numeros2, duplicar2);
                
                // Se manda a llamar la nueva operación
                const resultadoCuadrado = aplicarOperacionAArray2(numeros2, aCuadrado);

                // Mostramos ambos resultados en el mismo div
                const contenedor2 = document.getElementById('resultado-map-funcion2');
                
                contenedor2.innerHTML = `
                    <p>Resultado de <strong>duplicar</strong>: [${resultadoDuplicado2.join(', ')}]</p>
                    <p>Resultado de <strong>elevar al cuadrado</strong>: [${resultadoCuadrado.join(', ')}]</p>
                `;
            </script>
        </div>
    </div>
</section>


<section class="ejercicio">
    <h2>Ejemplo de Closure: Contador Privado</h2>
    <p class="descripcion">
        La función <code>crearContador</code> define una variable <code>contador</code> que no es accesible desde el exterior. Sin embargo, la función interna que se devuelve puede acceder y modificar esta variable, creando un estado privado que persiste entre llamadas.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones8.PNG" alt="Código del ejercicio de closure">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-closure"></div>

            <script>
                // La función "fábrica" que crea nuestro contador
                function crearContador() {
                    let contador = 0; // Esta variable es privada

                    // Se retorna una nueva función que "cierra" o "atrapa" la variable 'contador'
                    return function() {
                        contador += 1;
                        return contador;
                    };
                }

                // Creamos una instancia del contador. 
                // miContador ahora es la función interna que fue retornada.
                const miContador = crearContador();

                // Obtenemos el contenedor para mostrar el resultado
                const contenedor3 = document.getElementById('resultado-closure');

                // Llamamos a la función varias veces y mostramos cómo el estado se mantiene
                let salida = '';
                salida += `<p>Primera llamada: <strong>${miContador()}</strong></p>`; // Muestra 1
                salida += `<p>Segunda llamada: <strong>${miContador()}</strong></p>`; // Muestra 2
                salida += `<p>Tercera llamada: <strong>${miContador()}</strong></p>`; // Muestra 3

                contenedor3.innerHTML = salida;
            </script>
        </div>
    </div>
</section>


<section class="ejercicio">
    <h2>Ejemplo de Closures: Fábrica de Saludos</h2>
    <p class="descripcion">
        Este ejercicio demuestra cómo una función puede "fabricar" y devolver otras funciones. La función interna recuerda la variable <code>saludo</code> de su función contenedora, un concepto clave de los closures en JavaScript.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones9.PNG" alt="Código del ejercicio de closures">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-saludos"></div>

            <script>
                // 1. Definición de la función "fábrica"
                function crearSaludo(saludo) {
                    // Devuelve una nueva función que recuerda el 'saludo'
                    return function(nombre) {
                        return `${saludo}, ${nombre}!`;
                    };
                }

                // 2. Creación de funciones de saludo especializadas
                const saludarEnEspanol = crearSaludo('Hola');
                const saludarEnIngles = crearSaludo('Hello');
                // 4. Se agrega otra función para un saludo diferente (en francés)
                const saludarEnFrances = crearSaludo('Bonjour');

                // 3. Pruebas
                const contenedor4 = document.getElementById('resultado-saludos');
                let salida2 = '';

                // Usamos las nuevas funciones
                salida2+= `<p>${saludarEnEspanol('Juan')}</p>`;
                salida2 += `<p>${saludarEnIngles('John')}</p>`;
                salida2 += `<p>${saludarEnFrances('Jean')}</p>`;
                
                contenedor4.innerHTML = salida2;
            </script>
        </div>
    </div>
</section>


<section class="ejercicio">
    <h2>Funciones que Crean Otras Funciones (Closures)</h2>
    <p class="descripcion">
        Este ejercicio demuestra cómo la función <code>crearMultiplicador</code> actúa como una "fábrica" que produce funciones especializadas. Cada nueva función (<code>duplicar</code>, <code>triplicar</code>) recuerda el <code>factor</code> con el que fue creada.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones10.PNG" alt="Código del ejercicio de multiplicador">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-multiplicador"></div>

            <script>
                // La función "fábrica" que crea multiplicadores
                function crearMultiplicador(factor) {
                    // Retorna una nueva función que recuerda el 'factor'
                    return function(numero) {
                        return numero * factor;
                    };
                }

                // Creamos funciones especializadas usando la fábrica
                const duplicar3 = crearMultiplicador(2);
                const triplicar = crearMultiplicador(3);

                // Probamos las nuevas funciones
                const contenedor5 = document.getElementById('resultado-multiplicador');
                
                // Usamos las funciones creadas y mostramos su salida
                contenedor5.innerHTML = `
                    <p>Llamando a duplicar(5): <strong>${duplicar(5)}</strong></p>
                    <p>Llamando a triplicar(5): <strong>${triplicar(5)}</strong></p>
                `;
            </script>
        </div>
    </div>
</section>


<section class="ejercicio">
    <h2>Patrón Revelador (Revealing Module Pattern)</h2>
    <p class="descripcion">
        El patrón revelador utiliza un <strong>closure</strong> para encapsular la lógica y exponer solo ciertas partes de un objeto o módulo. Esto permite ocultar la implementación interna y proteger el estado de las variables privadas.
    </p>
    <div class="contenido">
        <div class="codigo-img">
            <img src="../Imagenes/funciones11.PNG" alt="Código del patrón revelador">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <div id="resultado-patron-revelador"></div>

            <script>
                // Se usa un nombre de variable único para el módulo
                const miModuloContador = (function () {
                    // --- PARTE PRIVADA ---
                    // Esta variable no se puede acceder desde fuera del módulo.
                    let contadorPrivado = 0;

                    function incrementarContador() {
                        contadorPrivado++;
                    }

                    function obtenerValorContador() {
                        return contadorPrivado;
                    }

                    // --- PARTE PÚBLICA (LO QUE SE REVELA) ---
                    // Devolvemos un objeto con las funciones que queremos que sean públicas.
                    return {
                        incrementar: incrementarContador,
                        obtener: obtenerValorContador
                    };
                })(); // Los paréntesis finales () ejecutan la función inmediatamente.

                // --- USO DEL MÓDULO ---
                
                // Usamos un nombre de variable único para el contenedor
                const contenedorModulo = document.getElementById('resultado-patron-revelador');
                let salidaModulo = '';

                // 1. Obtenemos el valor inicial (debería ser 0)
                salidaModulo += `<p>Valor inicial del contador: <strong>${miModuloContador.obtener()}</strong></p>`;

                // 2. Incrementamos el valor dos veces
                miModuloContador.incrementar();
                miModuloContador.incrementar();
                
                // 3. Obtenemos el nuevo valor (debería ser 2)
                salidaModulo += `<p>Valor después de llamar a incrementar() dos veces: <strong>${miModuloContador.obtener()}</strong></p>`;

                // Intento de acceso a la variable privada (esto daría error, demostrando que está protegida)
                salidaModulo += `<p>Intento de acceder a 'contadorPrivado' directamente: <strong>${typeof miModuloContador.contadorPrivado}</strong></p>`; // Salida: undefined

                contenedorModulo.innerHTML = salidaModulo;
            </script>
        </div>
    </div>
</section>


<section class="ejercicio">
    <h2>Juego: Adivina el Número</h2>
    <p class="descripcion">
        Un juego completo que utiliza closures para generar un número secreto y gestionar los intentos del jugador. Haz clic en el botón para comenzar.
    </p>
    <div class="contenido">
        <div class="codigo-img">
          <img src="../Imagenes/juego.PNG" alt="">
          <img src="../Imagenes/juego2.PNG" alt="">
        </div>
        <div class="codigo-ejecucion">
            <h2>¡A Jugar!</h2>
            <button id="iniciar-juego-btn" style="padding: 10px 15px; font-size: 16px;">Iniciar Juego</button>
            <p id="estado-juego" style="margin-top: 15px; font-style: italic;">Presiona el botón para empezar una nueva partida.</p>

            <script>
                // Función 1: Crea una función que genera un número aleatorio en un rango.
                function crearGeneradorNumeroAleatorio(min, max) {
                    // La función devuelta "recuerda" los valores min y max.
                    return function() {
                        return Math.floor(Math.random() * (max - min + 1)) + min;
                    };
                }

                // Función 2: Crea la lógica del juego.
                function crearJuegoAdivinarNumero(generadorNumero) {
                    // Estas variables son PRIVADAS gracias al closure.
                    const numeroAleatorio = generadorNumero();
                    let intentos = 0;
                    
                    console.log(`(Pista para depuración: el número secreto es ${numeroAleatorio})`);

                    // La función devuelta es la que el jugador usará para adivinar.
                    return function(adivina) {
                        intentos++;
                        if (adivina < numeroAleatorio) {
                            return `El número es mayor. Intentos: ${intentos}`;
                        } else if (adivina > numeroAleatorio) {
                            return `El número es menor. Intentos: ${intentos}`;
                        } else {
                            return `¡Felicidades! Adivinaste el número en ${intentos} intentos.`;
                        }
                    };
                }
                
                // Función 3: Controla el flujo principal del juego.
                function iniciarJuego() {
                    const estadoJuego = document.getElementById('estado-juego');
                    estadoJuego.textContent = "Juego en curso... Revisa las ventanas emergentes.";

                    const rangoMin = parseInt(prompt("Ingresa el valor mínimo del rango:"));
                    const rangoMax = parseInt(prompt("Ingresa el valor máximo del rango:"));

                    // Validamos que los rangos sean números válidos
                    if (isNaN(rangoMin) || isNaN(rangoMax) || rangoMin >= rangoMax) {
                        alert("Por favor, ingresa un rango válido.");
                        estadoJuego.textContent = "Error en el rango. Vuelve a iniciar el juego.";
                        return;
                    }

                    const generadorNumero = crearGeneradorNumeroAleatorio(rangoMin, rangoMax);
                    let juego = crearJuegoAdivinarNumero(generadorNumero);
                    let resultado;

                    do {
                        const adivina = parseInt(prompt(`Adivina el número entre ${rangoMin} y ${rangoMax}:`));
                        
                        if (isNaN(adivina)) {
                            alert("Por favor, ingresa un número.");
                            continue; // Salta esta iteración y pide el número de nuevo
                        }

                        resultado = juego(adivina);
                        alert(resultado);

                    } while (!resultado.includes("¡Felicidades!"));
                    
                    estadoJuego.textContent = "¡Juego terminado! Presiona el botón para jugar de nuevo.";

                    if (confirm("¿Quieres jugar de nuevo?")) {
                        iniciarJuego();
                    }
                }

                // En lugar de iniciar el juego directamente, lo asociamos al clic del botón.
                document.getElementById('iniciar-juego-btn').addEventListener('click', iniciarJuego);
            </script>
        </div>
    </div>
</section>

<section class="ejercicio">
    <h2>Ejercicio Final: Memoización con Closures y Funciones de Orden Superior</h2>
    <p class="descripcion">
        La <strong>memoización</strong> es una técnica de optimización que guarda los resultados de funciones costosas y los devuelve desde un caché cuando se repiten las mismas entradas. Este ejemplo crea una función <code>memoizar</code> que envuelve a otra función (en este caso, un cálculo de factorial) y utiliza un <strong>closure</strong> para mantener el caché privado.
    </p>
    <div class="contenido">
        <div class="codigo-img">
          <img src="..//Imagenes/funcionesfinal1.PNG" alt="">
          <img src="../Imagenes/funcionesfinal2.PNG" alt="">
        </div>
        <div class="codigo-ejecucion">
            <h2>Funcionamiento del código</h2>
            <p><em>Revisa la consola (F12) para ver cuándo se realiza un cálculo y cuándo se devuelve un resultado desde el caché.</em></p>
            <div id="resultado-memoizacion"></div>

            <script>
                // La función de orden superior. Acepta una función 'fn' y devuelve una nueva versión con memoria.
                function memoizar(fn) {
                    // 1. El caché se crea aquí y es PRIVADO gracias al closure.
                    const cache = {};

                    // 2. Se retorna una nueva función que envuelve a la original.
                    return function(arg) {
                        // 3. Revisa si el resultado ya está en el caché.
                        if (cache[arg]) {
                            console.log(`Devolviendo resultado para '${arg}' desde el caché.`);
                            return cache[arg];
                        } else {
                            // 4. Si no está, ejecuta la función original, guarda el resultado y lo devuelve.
                            console.log(`Calculando resultado para '${arg}' por primera vez.`);
                            const resultado = fn(arg);
                            cache[arg] = resultado;
                            return resultado;
                        }
                    };
                }

                // Una función de ejemplo que podría ser "lenta" o "costosa".
                const factorialLento = (n) => {
                    if (n === 0 || n === 1) return 1;
                    return n * factorialLento(n - 1);
                };

                // Creamos una nueva versión de nuestra función factorial que tiene "memoria".
                const factorialConMemoria = memoizar(factorialLento);

                // --- PRUEBAS ---
                const contenedorMemo = document.getElementById('resultado-memoizacion');
                let salidaMemo = '';

                salidaMemo += `<p>Llamando a factorialConMemoria(5)...</p>`;
                const res1 = factorialConMemoria(5); // Se calcula por primera vez.
                salidaMemo += `<p>Resultado: ${res1}</p>`;

                salidaMemo += `<p>Llamando a factorialConMemoria(5) de nuevo...</p>`;
                const res2 = factorialConMemoria(5); // Se devuelve desde el caché al instante.
                salidaMemo += `<p>Resultado: ${res2}</p>`;
                
                salidaMemo += `<p>Llamando a factorialConMemoria(6)...</p>`;
                const res3 = factorialConMemoria(6); // Se calcula por primera vez.
                salidaMemo += `<p>Resultado: ${res3}</p>`;
                
                contenedorMemo.innerHTML = salidaMemo;
            </script>
        </div>
    </div>
</section>


</body>
<script>
            for (let img of document.getElementsByClassName('codigo-img')) {
            img.addEventListener('click', (e) => {
                console.log("Clic en:", e.target);
                e.target.requestFullscreen();
            });
          }
</script>
</html>